---
title: "Chapter 1: Core Primitives"
description: Building the cryptographic foundation of our blockchain
---

import { Tabs, TabItem, Aside, Code } from '@astrojs/starlight/components';

# Chapter 1: Core Primitives

Every blockchain rests on a foundation of cryptographic primitives. In this chapter, we'll build the `core` crate ‚Äî the bedrock upon which everything else depends.

## What We're Building

By the end of this chapter, you'll have implemented:

| Module | Purpose |
|--------|---------|
| `hash.rs` | Blake3 hashing utilities |
| `crypto.rs` | Ed25519 signatures and addresses |
| `account.rs` | Account state representation |
| `transaction.rs` | Transaction types and signing |
| `block.rs` | Block and header structures |
| `merkle.rs` | Merkle tree for transaction proofs |

---

## 1.1 Hashing with Blake3

Hashing is the heartbeat of a blockchain. We use it for:
- Block identification
- Transaction fingerprinting
- Merkle tree construction
- Address derivation

### Why Blake3?

https://github.com/BLAKE3-team/BLAKE3/

| Algorithm | Speed | Security | Output |
|-----------|-------|----------|--------|
| SHA-256 | Moderate | Proven | 32 bytes |
| Keccak-256 | Moderate | Proven | 32 bytes |
| **Blake3** | **Very Fast** | Modern | 32 bytes |

Blake3 is extremely fast (especially on modern CPUs with SIMD) while maintaining strong security properties. It's based on the BLAKE2 design but optimized for parallelism and performance.

<Aside type="note" title="Learn More About Blake3">
- [BLAKE3 Paper (PDF)](https://cgi.cse.unsw.edu.au/~cs4601/refs/papers/blake3.pdf) ‚Äî The original cryptographic specification
- [BLAKE Hash Function (Wikipedia)](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) ‚Äî History and context
- [BLAKE3 Deep Dive (Video)](https://www.youtube.com/watch?v=nk4nefmguZk) ‚Äî Excellent technical explanation
- [BLAKE3 CryptAnalysis](https://eprint.iacr.org/2019/1492.pdf) ‚Äî Cryptanalysis of various cryptographic Algorithms
</Aside>

### The Hash Type

We wrap the raw 32-byte array in a newtype for better ergonomics:

```rust
/// A 256-bit hash value.
pub type H256 = [u8; 32];

/// A wrapper type for H256 with Display and Debug formatting.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct Hash(pub H256);

impl Hash {
    /// The zero hash (all zeros).
    pub const ZERO: Self = Self([0u8; 32]);

    /// Convert to a hex string.
    pub fn to_hex(&self) -> String {
        hex::encode(self.0)
    }

    /// Parse from a hex string.
    pub fn from_hex(s: &str) -> Result<Self, hex::FromHexError> {
        let bytes = hex::decode(s)?;
        if bytes.len() != 32 {
            return Err(hex::FromHexError::InvalidStringLength);
        }
        let mut arr = [0u8; 32];
        arr.copy_from_slice(&bytes);
        Ok(Self(arr))
    }
}
```

<Aside type="tip">
The `Hash::ZERO` constant is useful for genesis blocks and empty merkle roots.
</Aside>

### Hashing Functions

```rust
/// Hash arbitrary data using Blake3.
pub fn hash(data: &[u8]) -> Hash {
    Hash(blake3::hash(data).into())
}

/// Hash multiple pieces of data by concatenating them.
pub fn hash_concat(parts: &[&[u8]]) -> Hash {
    let mut hasher = blake3::Hasher::new();
    for part in parts {
        hasher.update(part);
    }
    Hash(hasher.finalize().into())
}
```

<Aside type="tip">
`hash_concat` doesn't allocate a concatenated buffer ‚Äî it streams data into the hasher incrementally using `update()`. This is memory-efficient for merkle trees where we hash pairs of 32-byte nodes repeatedly.
</Aside>

---

## 1.2 Cryptographic Identities

Digital signatures let us prove ownership without revealing secrets. We use **Ed25519** for its speed and compact 64-byte signatures.

<Aside type="tip" title="Bank Analogy">
Think of blockchain cryptography like a bank account:

| Blockchain | Bank Equivalent |
|------------|-----------------|
| **Private Key** | Your signature + PIN (secret, never share!) |
| **Public Key** | Your ID card (proves who you are) |
| **Address** | Your account number (share to receive funds) |
| **Signing a Transaction** | Signing a check to authorize payment |
| **Account** | Your bank account (balance + transaction history) |

The key difference: in a bank, the bank verifies your signature. On a blockchain, **anyone** can verify it using math ‚Äî no trusted third party needed.
</Aside>

### Address Derivation

An address is derived from a public key:

```
Public Key (32 bytes)
        ‚Üì
   Blake3 Hash
        ‚Üì
 First 20 bytes = Address
```

```rust
pub type AddressBytes = [u8; 20];

#[derive(Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct Address(pub AddressBytes);

impl Address {
    pub const ZERO: Self = Self([0u8; 20]);

    pub fn to_hex(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }

    pub fn from_hex(s: &str) -> Result<Self, CryptoError> {
        let s = s.strip_prefix("0x").unwrap_or(s);
        let bytes = hex::decode(s).map_err(|_| CryptoError::InvalidAddress)?;
        // ... validation
    }
}
```

<Aside>
We use 20 bytes (160 bits) for addresses, matching Ethereum's format. This provides a good balance between collision resistance and space efficiency.
</Aside>

### The Keypair

A `Keypair` bundles signing and verification capabilities:

```rust
pub struct Keypair {
    signing_key: SigningKey,
    pub public_key: PublicKey,
}

impl Keypair {
    /// Generate a new random keypair.
    pub fn generate() -> Self {
        let signing_key = SigningKey::generate(&mut OsRng);
        let verifying_key = signing_key.verifying_key();
        Self {
            signing_key,
            public_key: PublicKey(verifying_key),
        }
    }

    /// Get the address derived from the public key.
    pub fn address(&self) -> Address {
        self.public_key.to_address()
    }

    /// Sign a message.
    pub fn sign(&self, message: &[u8]) -> Signature {
        let sig = self.signing_key.sign(message);
        Signature(sig.to_bytes())
    }
}
```

### Usage Example

```rust
// Generate a new identity
let keypair = Keypair::generate();
println!("Address: {}", keypair.address());

// Sign a message
let message = b"hello blockchain";
let signature = keypair.sign(message);

// Verify the signature
assert!(keypair.public_key.verify(message, &signature).is_ok());
```

---

## 1.3 Account State

An account represents an entity on the blockchain ‚Äî either a user or a smart contract.

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Account {
    /// Transaction count / sequence number.
    pub nonce: u64,
    /// Account balance in the native token.
    pub balance: u64,
    /// Hash of the contract bytecode (None for EOAs).
    pub code_hash: Option<Hash>,
    /// Root hash of the account's storage trie.
    pub storage_root: Hash,
}
```

### Two Types of Accounts

<Tabs>
  <TabItem label="User Account (EOA)">
```rust
// Externally Owned Account - controlled by a private key
let user = Account::new_user(1000);
assert!(user.is_eoa());
assert_eq!(user.code_hash, None);
```
  </TabItem>
  <TabItem label="Contract Account">
```rust
// Contract account - has associated bytecode
let code_hash = hash(b"contract bytecode");
let contract = Account::new_contract(code_hash);
assert!(contract.is_contract());
assert_eq!(contract.code_hash, Some(code_hash));
```
  </TabItem>
</Tabs>

### Why Two Types of Accounts?

> **Core analogy (one you can say in one breath):**
> An EOA is like a personal bank account you control directly, while a contract account is like an automated corporate account that can only move money according to pre-written rules.

---

#### üßë‚Äçüíº EOA (Externally Owned Account)

**Analogy: Your personal savings/checking account**

- You control it with your signature ‚Üí like signing a cheque or authorizing a transaction with your PIN
- Money moves only when **you explicitly approve** it
- No internal logic ‚Äî it just sends and receives money

**Blockchain mapping:**
- Controlled by a private key
- Can initiate transactions
- No code, just balance + nonce

---

#### üè¢ Contract Account

**Analogy: A corporate bank account with standing instructions (or an automated escrow)**

- No human "signs" transactions directly
- Money moves only when **predefined rules are satisfied** (e.g., "release funds after both parties approve")
- Cannot act on its own ‚Äî it **reacts** when someone triggers it

**Blockchain mapping:**
- Controlled by code
- Cannot initiate transactions by itself
- Executes logic when called

---

#### Why Do We Need Both?

**One subtle but important point:** A contract account never "decides" to send money ‚Äî it only executes instructions when someone calls it.

**Bank analogy:** A corporate account won't randomly transfer funds. Someone submits a request, and the bank checks the rules before executing it.

**The separation:** Blockchain separates **identity** (EOA) from **automation** (contracts) ‚Äî like separating a person from the company policies they operate under.

<Aside type="tip">
**Quick reference:**
- **EOA** = human-controlled account (signs transactions)
- **Contract** = rule-controlled account (executes code)
</Aside>



### Nonce: Preventing Replay Attacks

The `nonce` field is critical for security.

> **Core analogy:**
> A nonce is like a cheque number ‚Äî the bank will only process each cheque number once, so you can't reuse an old signed cheque to withdraw money again.

---

#### üßæ Cheque Number (Banking)

- Every cheque has a unique, increasing number
- The bank records the last used number
- Reusing an old cheque = **rejected**
- Skipping ahead is allowed, but going backward isn't

#### üî¢ Nonce (Blockchain)

- Every account has a nonce (transaction counter)
- Each transaction must use the **next** nonce
- Replaying an old signed transaction = **rejected**
- Ensures transactions execute **once** and **in order**

---

```rust
impl Account {
    pub fn increment_nonce(&mut self) {
        self.nonce = self.nonce.saturating_add(1);
    }
}
```

Every transaction must include the sender's current nonce. This prevents:
- **Replay attacks** ‚Äî can't resubmit the same transaction
- **Transaction ordering** ‚Äî nonces must be sequential

---

## 1.4 Transactions

A transaction is a signed request to change blockchain state.

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Transaction {
    pub nonce: u64,              // Sender's nonce
    pub from: Address,           // Sender
    pub to: Option<Address>,     // Recipient (None = deploy)
    pub value: u64,              // Amount to transfer
    pub data: Vec<u8>,           // Calldata or bytecode
    pub gas_limit: u64,          // Max gas
    pub gas_price: u64,          // Price per gas unit
    pub signature: Signature,    // Ed25519 signature
}
```

### Understanding Gas: `gas_limit` and `gas_price`

> **Core analogy:**
> Gas is like a **wire transfer fee** ‚Äî you set a maximum budget (`gas_limit`) and a rate you're willing to pay (`gas_price`). The bank charges you only for the actual work done, up to your limit.

---

#### üè¶ Wire Transfer Fee (Banking)

- **Fee cap**: "I'll pay up to $50 for this transfer"
- **Priority rate**: Standard ($5), Express ($15), Urgent ($30)
- **Actual charge**: Bank charges based on complexity, but never exceeds your cap
- **If cap too low**: Transfer is rejected ("insufficient fee budget")

#### ‚õΩ Gas (Blockchain)

- **`gas_limit`**: Maximum gas units you're willing to consume
- **`gas_price`**: How much you pay per gas unit (higher = faster inclusion)
- **Actual cost**: `gas_used √ó gas_price` (refund unused gas)
- **If limit too low**: Transaction fails ("out of gas"), but fees are still consumed

---

#### Why Two Numbers? Why Not Just a Single Fee?

> **Question:** Can't we just say "I'll pay $10 for this transaction" instead of `gas_limit` √ó `gas_price`?

**The key insight:** These two numbers measure **different things**.

| Field | What It Measures | Who Controls It |
|-------|------------------|-----------------|
| `gas_limit` | **Computation** ‚Äî how much work | The operation itself (deterministic) |
| `gas_price` | **Priority** ‚Äî how fast you want it | You (market-driven) |

---

**üè¶ Banking Analogy:**

Think of it like shipping a package:

- **Weight/Size** (gas_limit) = How big is your package? A letter vs a refrigerator need different resources.
- **Shipping Speed** (gas_price) = Standard, Express, or Overnight? You choose based on urgency.

You can't combine these into one number because:
- A **small package sent overnight** (low gas, high price) costs differently than
- A **huge package sent standard** (high gas, low price)

---

**Why separation matters:**

1. **Refunds work** ‚Äî You set gas_limit=100,000 but only use 21,000? You get 79,000 √ó gas_price back. A single fee = no refunds.

2. **Predictable estimation** ‚Äî Gas for a transfer is always ~21,000. Gas for a complex contract call might be 500,000. You can estimate this *before* choosing your price.

3. **Market flexibility** ‚Äî Network busy? Raise gas_price, not gas_limit. Your operation doesn't need more computation, just faster inclusion.

4. **Prevents overpaying** ‚Äî Single fee = you'd always pay maximum. Two numbers = pay only for actual work done.

---

#### Wait ‚Äî Isn't Gas Fixed for Simple Transfers?

**Yes!** For EOA ‚Üí EOA transfers (no contract code), gas is **always 21,000**. It's deterministic:

```
Verify signature ‚Üí Check balance ‚Üí Transfer value ‚Üí Increment nonce
```

Same steps every time = same gas every time.

**So why have `gas_limit` at all?**

| Transaction Type | Gas Usage |
|------------------|-----------|
| EOA ‚Üí EOA transfer | Fixed: 21,000 |
| Contract deployment | Variable: depends on bytecode size |
| Contract call | Variable: depends on code execution path |

The `Transaction` struct handles **all** types. For simple transfers, `gas_limit = 21,000` is just a formality. For contract interactions, it's crucial ‚Äî the same function might use 50,000 or 500,000 gas depending on inputs and state.

<Aside type="tip">
**Rule of thumb:**
- Simple transfer? `gas_limit = 21,000` (fixed, no thinking needed)
- Contract call? Estimate first, then add ~20% buffer
</Aside>

---

#### Why Gas Exists

| Problem | How Gas Solves It |
|---------|-------------------|
| Infinite loops in contracts | Execution stops when gas runs out |
| Spam transactions | Every operation costs money |
| Resource fairness | Users pay for computation they consume |
| Miner/validator incentives | Gas fees reward block producers |

---

#### Quick Reference

| Field | What It Means | Banking Equivalent |
|-------|---------------|-------------------|
| `gas_limit` | Max gas you'll spend | Fee budget cap |
| `gas_price` | Cost per gas unit | Priority/speed tier |
| `gas_used` | Actual gas consumed | Actual fee charged |
| `gas_limit √ó gas_price` | Max possible cost | Worst-case fee |

<Aside type="caution">
**Important:** If a transaction fails (e.g., out of gas, contract reverts), you still pay for the gas consumed up to the failure point. It's like a wire transfer that fails halfway ‚Äî the bank still charges processing fees.
</Aside>

### Transaction Types

A blockchain supports three fundamental operations, all using the same `Transaction` struct:

```rust
// 1. Value Transfer
let transfer = Transaction::transfer(from, to, 1000, nonce, gas_price);

// 2. Contract Deployment (to = None)
let deploy = Transaction::deploy(from, bytecode, nonce, gas_limit, gas_price);

// 3. Contract Call
let call = Transaction::call(from, contract, calldata, value, nonce, gas_limit, gas_price);
```

---

#### 1Ô∏è‚É£ Value Transfer (EOA ‚Üí EOA)

> **Banking analogy:** A simple bank transfer ‚Äî move money from your account to someone else's.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | Recipient address | Who receives the money |
| `value` | Amount | How much to send |
| `data` | Empty (`[]`) | No instructions needed |
| `gas_limit` | 21,000 (fixed) | Always the same |

**What happens:**
```
1. Verify signature ‚úì
2. Check sender.balance ‚â• value + gas_fees ‚úì
3. sender.balance -= value
4. recipient.balance += value
5. sender.nonce += 1
```

---

#### 2Ô∏è‚É£ Contract Deployment

> **Banking analogy:** Opening a new automated escrow account with specific rules. You're not sending money to someone ‚Äî you're creating a new rule-based account.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | `None` | **No recipient** ‚Äî signals deployment |
| `value` | Usually 0 | Initial balance for contract (optional) |
| `data` | Bytecode | The contract's compiled code |
| `gas_limit` | Variable | Depends on bytecode size + initialization |

**What happens:**
```
1. Verify signature ‚úì
2. Compute contract address = hash(sender, nonce)
3. Create new account at that address
4. Store bytecode in contract account
5. Execute constructor (initialization code)
6. sender.nonce += 1
```

**Key insight:** The contract address is deterministic ‚Äî you can know it *before* deploying!

---

#### 3Ô∏è‚É£ Contract Call

> **Banking analogy:** Triggering a standing instruction on a corporate account. You send a request (and optionally money), and the account's pre-programmed rules execute.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | Contract address | Which contract to interact with |
| `value` | Optional | Send money along with the call |
| `data` | Calldata | Function selector + encoded arguments |
| `gas_limit` | Variable | Depends on what the code does |

**What happens:**
```
1. Verify signature ‚úì
2. Load contract code from `to` address
3. Execute code with `data` as input
4. Code may: read/write storage, send funds, call other contracts
5. If success: state changes persist
6. If failure: all changes reverted (but gas still consumed!)
```

---

#### Quick Comparison

| | Transfer | Deploy | Call |
|--|----------|--------|------|
| **`to`** | Recipient | `None` | Contract |
| **`data`** | Empty | Bytecode | Calldata |
| **`value`** | Amount | Initial balance | Payment to contract |
| **Gas** | Fixed (21k) | Variable | Variable |
| **Creates account?** | No* | Yes | No |
| **Executes code?** | No | Constructor only | Yes |

*\*Transfer creates recipient account if it doesn't exist (with zero code)*

<Aside type="note">
**How does the blockchain know which type?**
- `to == None` ‚Üí Deployment
- `to == EOA` (no code) ‚Üí Transfer
- `to == Contract` (has code) ‚Üí Call

The `data` field confirms intent: empty for transfers, bytecode for deploy, calldata for calls.
</Aside>

### Signing Transactions

We sign the hash of the transaction data (excluding the signature itself):

```rust
impl Transaction {
    pub fn signing_hash(&self) -> Hash {
        // Serialize everything except signature
        let unsigned = UnsignedTransaction { /* ... */ };
        let encoded = bincode::serialize(&unsigned).unwrap();
        hash(&encoded)
    }

    pub fn sign(&mut self, keypair: &Keypair) {
        let hash = self.signing_hash();
        self.signature = keypair.sign_hash(&hash);
    }
}
```

### Contract Address Derivation

When deploying a contract, the address is deterministic:

```rust
pub fn contract_address(&self) -> Option<Address> {
    if !self.is_deploy() {
        return None;
    }
    // Address = hash(sender || nonce)[0..20]
    let mut data = Vec::new();
    data.extend_from_slice(&self.from.0);
    data.extend_from_slice(&self.nonce.to_le_bytes());
    let h = hash(&data);
    // First 20 bytes
    Some(Address(h.0[..20].try_into().unwrap()))
}
```

<Aside type="caution">
This means you can predict contract addresses before deployment! This enables patterns like counterfactual instantiation.
</Aside>

---

## 1.5 Blocks

A block packages transactions into an ordered, tamper-evident unit.

### Block Header

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockHeader {
    pub height: u64,           // Block number
    pub timestamp: u64,        // Unix timestamp
    pub prev_hash: Hash,       // Link to parent
    pub merkle_root: Hash,     // Transaction summary
    pub state_root: Hash,      // World state after block
    pub author: Address,       // Block producer
    pub difficulty: u64,       // Always 1 for PoA
    pub nonce: u64,            // Unused in PoA
}
```

### The Chain of Blocks

Each block references its parent via `prev_hash`:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Block 0 ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÇ Block 1 ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÇ Block 2 ‚îÇ
‚îÇ Genesis ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
prev_hash=0    prev_hash=     prev_hash=
               hash(Block0)   hash(Block1)
```

### Genesis Block

The genesis block is special ‚Äî it has no parent:

```rust
impl Block {
    pub fn genesis(authority: Address) -> Self {
        Self {
            header: BlockHeader {
                height: 0,
                timestamp: BlockHeader::current_timestamp(),
                prev_hash: Hash::ZERO,  // No parent!
                merkle_root: Hash::ZERO,
                state_root: Hash::ZERO,
                author: authority,
                difficulty: 1,
                nonce: 0,
            },
            transactions: Vec::new(),
            signature: Signature::default(),
        }
    }
}
```

### Block Signing (PoA)

In Proof of Authority, the designated authority signs each block:

```rust
impl Block {
    pub fn sign(&mut self, keypair: &Keypair) {
        let hash = self.header.hash();
        self.signature = keypair.sign_hash(&hash);
    }

    pub fn verify_signature(&self, public_key: &PublicKey) -> bool {
        let hash = self.header.hash();
        public_key.verify(hash.as_bytes(), &self.signature).is_ok()
    }
}
```

---

## 1.6 Merkle Trees

A merkle tree lets us summarize many items into a single hash, with efficient proofs.

### Structure

```
        Root
       /    \
      H01    H23
     /  \   /  \
    H0  H1 H2  H3   ‚Üê Transaction hashes
```

### Computing the Root

```rust
pub fn merkle_root(hashes: &[Hash]) -> Hash {
    if hashes.is_empty() {
        return Hash::ZERO;
    }
    if hashes.len() == 1 {
        return hashes[0];
    }

    let mut current_level: Vec<Hash> = hashes.to_vec();

    while current_level.len() > 1 {
        let mut next_level = Vec::new();
        for chunk in current_level.chunks(2) {
            let combined = if chunk.len() == 2 {
                hash_concat(&[chunk[0].as_ref(), chunk[1].as_ref()])
            } else {
                // Odd number: hash with itself
                hash_concat(&[chunk[0].as_ref(), chunk[0].as_ref()])
            };
            next_level.push(combined);
        }
        current_level = next_level;
    }

    current_level[0]
}
```

### Why Merkle Trees?

1. **Integrity** ‚Äî Any change to any transaction changes the root
2. **Efficiency** ‚Äî Prove inclusion in O(log n) space
3. **Light clients** ‚Äî Verify transactions without full block data

### Merkle Proofs

```rust
pub struct MerkleProof {
    pub leaf: Hash,           // The item being proven
    pub siblings: Vec<Hash>,  // Sibling hashes on path to root
    pub directions: Vec<bool>, // Left or right at each level
}
```

To verify: reconstruct the path from leaf to root using siblings.

---

## Summary

We've built the cryptographic foundation:

| Component | What It Does |
|-----------|--------------|
| `Hash` | 256-bit Blake3 digest |
| `Address` | 160-bit identity derived from public key |
| `Keypair` | Ed25519 key pair for signing |
| `Account` | User or contract state |
| `Transaction` | Signed state change request |
| `Block` | Ordered batch of transactions |
| `MerkleTree` | Efficient transaction commitment |

### Tests Passing

```bash
$ cargo test -p minichain-core

running 47 tests
test account::tests::test_new_user_account ... ok
test crypto::tests::test_sign_and_verify ... ok
test block::tests::test_genesis_block ... ok
test merkle::tests::test_merkle_proof_valid ... ok
# ... all 47 tests pass
```

---

## What's Next?

With our primitives in place, we're ready to build the **storage layer** in [Chapter 2](/part2/chapter2-storage), where we'll persist accounts, blocks, and contract state using sled.
