---
title: "Chapter 1: Core Primitives"
description: Building the cryptographic foundation of our blockchain
---

import { Tabs, TabItem, Aside, Code } from '@astrojs/starlight/components';



Every blockchain rests on a foundation of cryptographic primitives. In this chapter, we'll build the `core` crate â€” the bedrock upon which everything else depends.

## What We're Building

By the end of this chapter, you'll have implemented:

| Module | Purpose |
|--------|---------|
| `hash.rs` | Blake3 hashing utilities |
| `crypto.rs` | Ed25519 signatures and addresses |
| `account.rs` | Account state representation |
| `transaction.rs` | Transaction types and signing |
| `block.rs` | Block and header structures |
| `merkle.rs` | Merkle tree for transaction proofs |

---

## 1.1 Hashing with Blake3

Hashing is the heartbeat of a blockchain. We use it for:
- Block identification
- Transaction fingerprinting
- Merkle tree construction
- Address derivation

### Why Blake3?

https://github.com/BLAKE3-team/BLAKE3/

| Algorithm | Speed | Security | Output |
|-----------|-------|----------|--------|
| SHA-256 | Moderate | Proven | 32 bytes |
| Keccak-256 | Moderate | Proven | 32 bytes |
| **Blake3** | **Very Fast** | Modern | 32 bytes |

Blake3 is extremely fast (especially on modern CPUs with SIMD) while maintaining strong security properties. It's based on the BLAKE2 design but optimized for parallelism and performance.

<Aside type="note" title="Learn More About Blake3">
- [BLAKE3 Paper (PDF)](https://cgi.cse.unsw.edu.au/~cs4601/refs/papers/blake3.pdf) â€” The original cryptographic specification
- [BLAKE Hash Function (Wikipedia)](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) â€” History and context
- [BLAKE3 Deep Dive (Video)](https://www.youtube.com/watch?v=nk4nefmguZk) â€” Excellent technical explanation
- [BLAKE3 CryptAnalysis](https://eprint.iacr.org/2019/1492.pdf) â€” Cryptanalysis of various cryptographic Algorithms
</Aside>

### The Hash Type

We wrap the raw 32-byte array in a newtype for better ergonomics:

```rust
/// A 256-bit hash value.
pub type H256 = [u8; 32];

/// A wrapper type for H256 with Display and Debug formatting.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct Hash(pub H256);

impl Hash {
    /// The zero hash (all zeros).
    pub const ZERO: Self = Self([0u8; 32]);

    /// Convert to a hex string.
    pub fn to_hex(&self) -> String {
        hex::encode(self.0)
    }

    /// Parse from a hex string.
    pub fn from_hex(s: &str) -> Result<Self, hex::FromHexError> {
        let bytes = hex::decode(s)?;
        if bytes.len() != 32 {
            return Err(hex::FromHexError::InvalidStringLength);
        }
        let mut arr = [0u8; 32];
        arr.copy_from_slice(&bytes);
        Ok(Self(arr))
    }
}
```

<Aside type="tip">
The `Hash::ZERO` constant is useful for genesis blocks and empty merkle roots.
</Aside>

### Hashing Functions

```rust
/// Hash arbitrary data using Blake3.
pub fn hash(data: &[u8]) -> Hash {
    Hash(blake3::hash(data).into())
}

/// Hash multiple pieces of data by concatenating them.
pub fn hash_concat(parts: &[&[u8]]) -> Hash {
    let mut hasher = blake3::Hasher::new();
    for part in parts {
        hasher.update(part);
    }
    Hash(hasher.finalize().into())
}
```

<Aside type="tip">
`hash_concat` doesn't allocate a concatenated buffer â€” it streams data into the hasher incrementally using `update()`. This is memory-efficient for merkle trees where we hash pairs of 32-byte nodes repeatedly.
</Aside>

---

## 1.2 Cryptographic Identities

Digital signatures let us prove ownership without revealing secrets. We use **Ed25519** for its speed and compact 64-byte signatures.

<Aside type="tip" title="Bank Analogy">
Think of blockchain cryptography like a bank account:

| Blockchain | Bank Equivalent |
|------------|-----------------|
| **Private Key** | Your signature + PIN (secret, never share!) |
| **Public Key** | Your ID card (proves who you are) |
| **Address** | Your account number (share to receive funds) |
| **Signing a Transaction** | Signing a check to authorize payment |
| **Account** | Your bank account (balance + transaction history) |

The key difference: in a bank, the bank verifies your signature. On a blockchain, **anyone** can verify it using math â€” no trusted third party needed.
</Aside>

### Address Derivation

An address is derived from a public key:

```
Public Key (32 bytes)
        â†“
   Blake3 Hash
        â†“
 First 20 bytes = Address
```

```rust
pub type AddressBytes = [u8; 20];

#[derive(Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct Address(pub AddressBytes);

impl Address {
    pub const ZERO: Self = Self([0u8; 20]);

    pub fn to_hex(&self) -> String {
        format!("0x{}", hex::encode(self.0))
    }

    pub fn from_hex(s: &str) -> Result<Self, CryptoError> {
        let s = s.strip_prefix("0x").unwrap_or(s);
        let bytes = hex::decode(s).map_err(|_| CryptoError::InvalidAddress)?;
        // ... validation
    }
}
```

<Aside>
We use 20 bytes (160 bits) for addresses, matching Ethereum's format. This provides a good balance between collision resistance and space efficiency.
</Aside>

### The Keypair

A `Keypair` bundles signing and verification capabilities:

```rust
pub struct Keypair {
    signing_key: SigningKey,
    pub public_key: PublicKey,
}

impl Keypair {
    /// Generate a new random keypair.
    pub fn generate() -> Self {
        let signing_key = SigningKey::generate(&mut OsRng);
        let verifying_key = signing_key.verifying_key();
        Self {
            signing_key,
            public_key: PublicKey(verifying_key),
        }
    }

    /// Get the address derived from the public key.
    pub fn address(&self) -> Address {
        self.public_key.to_address()
    }

    /// Sign a message.
    pub fn sign(&self, message: &[u8]) -> Signature {
        let sig = self.signing_key.sign(message);
        Signature(sig.to_bytes())
    }
}
```

### Usage Example

```rust
// Generate a new identity
let keypair = Keypair::generate();
println!("Address: {}", keypair.address());

// Sign a message
let message = b"hello blockchain";
let signature = keypair.sign(message);

// Verify the signature
assert!(keypair.public_key.verify(message, &signature).is_ok());
```

---

## 1.3 Account State

An account represents an entity on the blockchain â€” either a user or a smart contract.

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Account {
    /// Transaction count / sequence number.
    pub nonce: u64,
    /// Account balance in the native token.
    pub balance: u64,
    /// Hash of the contract bytecode (None for EOAs).
    pub code_hash: Option<Hash>,
    /// Root hash of the account's storage trie.
    pub storage_root: Hash,
}
```

### Two Types of Accounts

<Tabs>
  <TabItem label="User Account (EOA)">
```rust
// Externally Owned Account - controlled by a private key
let user = Account::new_user(1000);
assert!(user.is_eoa());
assert_eq!(user.code_hash, None);
```
  </TabItem>
  <TabItem label="Contract Account">
```rust
// Contract account - has associated bytecode
let code_hash = hash(b"contract bytecode");
let contract = Account::new_contract(code_hash);
assert!(contract.is_contract());
assert_eq!(contract.code_hash, Some(code_hash));
```
  </TabItem>
</Tabs>

### Why Two Types of Accounts?

> **Core analogy (one you can say in one breath):**
> An EOA is like a personal bank account you control directly, while a contract account is like an automated corporate account that can only move money according to pre-written rules.

---

#### ğŸ§‘â€ğŸ’¼ EOA (Externally Owned Account)

**Analogy: Your personal savings/checking account**

- You control it with your signature â†’ like signing a cheque or authorizing a transaction with your PIN
- Money moves only when **you explicitly approve** it
- No internal logic â€” it just sends and receives money

**Blockchain mapping:**
- Controlled by a private key
- Can initiate transactions
- No code, just balance + nonce

---

#### ğŸ¢ Contract Account

**Analogy: A corporate bank account with standing instructions (or an automated escrow)**

- No human "signs" transactions directly
- Money moves only when **predefined rules are satisfied** (e.g., "release funds after both parties approve")
- Cannot act on its own â€” it **reacts** when someone triggers it

**Blockchain mapping:**
- Controlled by code
- Cannot initiate transactions by itself
- Executes logic when called

---

#### Why Do We Need Both?

**One subtle but important point:** A contract account never "decides" to send money â€” it only executes instructions when someone calls it.

**Bank analogy:** A corporate account won't randomly transfer funds. Someone submits a request, and the bank checks the rules before executing it.

**The separation:** Blockchain separates **identity** (EOA) from **automation** (contracts) â€” like separating a person from the company policies they operate under.

<Aside type="tip">
**Quick reference:**
- **EOA** = human-controlled account (signs transactions)
- **Contract** = rule-controlled account (executes code)
</Aside>



### Nonce: Preventing Replay Attacks

The `nonce` field is critical for security.

> **Core analogy:**
> A nonce is like a cheque number â€” the bank will only process each cheque number once, so you can't reuse an old signed cheque to withdraw money again.

---

#### ğŸ§¾ Cheque Number (Banking)

- Every cheque has a unique, increasing number
- The bank records the last used number
- Reusing an old cheque = **rejected**
- Skipping ahead is allowed, but going backward isn't

#### ğŸ”¢ Nonce (Blockchain)

- Every account has a nonce (transaction counter)
- Each transaction must use the **next** nonce
- Replaying an old signed transaction = **rejected**
- Ensures transactions execute **once** and **in order**

---

```rust
impl Account {
    pub fn increment_nonce(&mut self) {
        self.nonce = self.nonce.saturating_add(1);
    }
}
```

Every transaction must include the sender's current nonce. This prevents:
- **Replay attacks** â€” can't resubmit the same transaction
- **Transaction ordering** â€” nonces must be sequential

---

## 1.4 Transactions

A transaction is a signed request to change blockchain state.

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Transaction {
    pub nonce: u64,              // Sender's nonce
    pub from: Address,           // Sender
    pub to: Option<Address>,     // Recipient (None = deploy)
    pub value: u64,              // Amount to transfer
    pub data: Vec<u8>,           // Calldata or bytecode
    pub gas_limit: u64,          // Max gas
    pub gas_price: u64,          // Price per gas unit
    pub signature: Signature,    // Ed25519 signature
}
```

### Understanding Gas: `gas_limit` and `gas_price`

> **Core analogy:**
> Gas is like a **wire transfer fee** â€” you set a maximum budget (`gas_limit`) and a rate you're willing to pay (`gas_price`). The bank charges you only for the actual work done, up to your limit.

---

#### ğŸ¦ Wire Transfer Fee (Banking)

- **Fee cap**: "I'll pay up to $50 for this transfer"
- **Priority rate**: Standard ($5), Express ($15), Urgent ($30)
- **Actual charge**: Bank charges based on complexity, but never exceeds your cap
- **If cap too low**: Transfer is rejected ("insufficient fee budget")

#### â›½ Gas (Blockchain)

- **`gas_limit`**: Maximum gas units you're willing to consume
- **`gas_price`**: How much you pay per gas unit (higher = faster inclusion)
- **Actual cost**: `gas_used Ã— gas_price` (refund unused gas)
- **If limit too low**: Transaction fails ("out of gas"), but fees are still consumed

---

#### Why Two Numbers? Why Not Just a Single Fee?

> **Question:** Can't we just say "I'll pay $10 for this transaction" instead of `gas_limit` Ã— `gas_price`?

**The key insight:** These two numbers measure **different things**.

| Field | What It Measures | Who Controls It |
|-------|------------------|-----------------|
| `gas_limit` | **Computation** â€” how much work | The operation itself (deterministic) |
| `gas_price` | **Priority** â€” how fast you want it | You (market-driven) |

---

**ğŸ¦ Banking Analogy:**

Think of it like shipping a package:

- **Weight/Size** (gas_limit) = How big is your package? A letter vs a refrigerator need different resources.
- **Shipping Speed** (gas_price) = Standard, Express, or Overnight? You choose based on urgency.

You can't combine these into one number because:
- A **small package sent overnight** (low gas, high price) costs differently than
- A **huge package sent standard** (high gas, low price)

---

##### Why separation matters

1. **Refunds work** â€” You set gas_limit=100,000 but only use 21,000? You get 79,000 Ã— gas_price back. A single fee = no refunds.

2. **Predictable estimation** â€” Gas for a transfer is always ~21,000. Gas for a complex contract call might be 500,000. You can estimate this *before* choosing your price.

3. **Market flexibility** â€” Network busy? Raise gas_price, not gas_limit. Your operation doesn't need more computation, just faster inclusion.

4. **Prevents overpaying** â€” Single fee = you'd always pay maximum. Two numbers = pay only for actual work done.

---

#### Wait â€” Isn't Gas Fixed for Simple Transfers?

**Yes!** For EOA â†’ EOA transfers (no contract code), gas is **always 21,000**. It's deterministic:

```
Verify signature â†’ Check balance â†’ Transfer value â†’ Increment nonce
```

Same steps every time = same gas every time.

**So why have `gas_limit` at all?**

| Transaction Type | Gas Usage |
|------------------|-----------|
| EOA â†’ EOA transfer | Fixed: 21,000 |
| Contract deployment | Variable: depends on bytecode size |
| Contract call | Variable: depends on code execution path |

The `Transaction` struct handles **all** types. For simple transfers, `gas_limit = 21,000` is just a formality. For contract interactions, it's crucial â€” the same function might use 50,000 or 500,000 gas depending on inputs and state.

<Aside type="tip">
**Rule of thumb:**
- Simple transfer? `gas_limit = 21,000` (fixed, no thinking needed)
- Contract call? Estimate first, then add ~20% buffer
</Aside>

---

#### Why Gas Exists

| Problem | How Gas Solves It |
|---------|-------------------|
| Infinite loops in contracts | Execution stops when gas runs out |
| Spam transactions | Every operation costs money |
| Resource fairness | Users pay for computation they consume |
| Miner/validator incentives | Gas fees reward block producers |

---

#### Quick Reference

| Field | What It Means | Banking Equivalent |
|-------|---------------|-------------------|
| `gas_limit` | Max gas you'll spend | Fee budget cap |
| `gas_price` | Cost per gas unit | Priority/speed tier |
| `gas_used` | Actual gas consumed | Actual fee charged |
| `gas_limit Ã— gas_price` | Max possible cost | Worst-case fee |

<Aside type="caution">
**Important:** If a transaction fails (e.g., out of gas, contract reverts), you still pay for the gas consumed up to the failure point. It's like a wire transfer that fails halfway â€” the bank still charges processing fees.
</Aside>

### Transaction Types

A blockchain supports three fundamental operations, all using the same `Transaction` struct.

#### Why Three Types? The Human-Machine Perspective

Every blockchain transaction is initiated by a **human** (EOA). Machines (contracts) cannot act on their own â€” they only react when triggered. This gives us a natural categorization:

| From | To | Type | What Happens |
|------|-----|------|--------------|
| Human | Human | **Transfer** | Money moves, nothing else |
| Human | New Machine | **Deploy** | A new autonomous program is born |
| Human | Existing Machine | **Call** | The machine wakes up and executes its code |

Notice what's missing: **Machine â†’ Anyone** as an initiating transaction. Contracts can send funds or call other contracts, but only *during* execution of a human-initiated transaction. A contract sitting idle will never "decide" to do something.

<Aside type="note" title="Why Can't Machines Initiate?">
This isn't a limitation â€” it's a fundamental design choice. Two parallels from computing:

**1. The Browser Event Loop**

JavaScript in your browser doesn't run continuously. It sits idle, waiting:
```
[idle] â†’ user clicks button â†’ [execute handler] â†’ [idle] â†’ user types â†’ [execute handler] â†’ [idle]
```
The code exists, but it only runs in response to human input. A webpage can't decide "I'll submit this form at 3 AM" without a human first setting that up.

*"But what about `setTimeout`?"* â€” Good question. `setTimeout(() => doSomething(), 5000)` seems autonomous, but:
- A human loaded the page (initiating the runtime)
- A human's action (or page load) executed the code that *scheduled* the timeout
- The browser must stay open â€” close it, and the timeout dies
- There's a persistent runtime (the browser process) actively watching the clock

Blockchains have no persistent runtime. There's no daemon thinking "is it time yet?" between blocks. The chain only "wakes up" when someone submits a transaction. `setTimeout` works because the browser is always running in the background; contracts have no background.

**2. CPU and I/O**

A CPU doesn't spontaneously read from disk. It executes instructions, and those instructions must originate from somewhere â€” ultimately, a human pressing the power button, launching a program, or triggering an action. Even "scheduled tasks" were scheduled by a human.

**Contracts work the same way:**
```
[idle] â†’ human sends transaction â†’ [execute code] â†’ [idle] â†’ human sends transaction â†’ [execute code]
```

A contract might *want* to do something (e.g., "release funds after 30 days"), but it cannot wake itself up. Someone must send a transaction to trigger the check. This is why "keeper" services exist â€” humans (or bots run by humans) that poke contracts to execute time-sensitive logic.
</Aside>

##### Why this matters

1. **Transfer (Human â†’ Human)**: The simplest case. No code runs. Just update two balances. This is like handing cash to a friend â€” no intermediary, no rules, just value moving.

2. **Deploy (Human â†’ New Machine)**: You're creating an autonomous agent that will live on the blockchain forever. It's not sending money *to* someone â€” it's bringing something *into existence*. That's why `to` is `None` â€” there's no recipient yet; you're creating one.

3. **Call (Human â†’ Existing Machine)**: You're waking up a sleeping program. The machine reads your input (`data`), possibly accepts your payment (`value`), executes its logic, and may trigger a chain reaction (calling other machines, sending funds, updating storage).

<Aside type="tip" title="The Subtle Insight">
Contracts are "second-class citizens" in terms of agency. They can hold money, enforce rules, and interact with the world â€” but only when a human pulls the trigger. This is a security feature: no autonomous infinite loops draining accounts at 3 AM.
</Aside>

#### One Struct, Three Interpretations

Rather than three separate structs, we use **one struct with different interpretations**:
- `to = None` â†’ Deployment (no recipient â€” you're creating one)
- `to = EOA` â†’ Transfer (recipient has no code)
- `to = Contract` â†’ Call (recipient has code, execute it)

This keeps the protocol simple while supporting all use cases:

```rust
// 1. Value Transfer
let transfer = Transaction::transfer(from, to, 1000, nonce, gas_price);

// 2. Contract Deployment (to = None)
let deploy = Transaction::deploy(from, bytecode, nonce, gas_limit, gas_price);

// 3. Contract Call
let call = Transaction::call(from, contract, calldata, value, nonce, gas_limit, gas_price);
```

---

#### 1ï¸âƒ£ Value Transfer (EOA â†’ EOA)

> **Banking analogy:** A simple bank transfer â€” move money from your account to someone else's.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | Recipient address | Who receives the money |
| `value` | Amount | How much to send |
| `data` | Empty (`[]`) | No instructions needed |
| `gas_limit` | 21,000 (fixed) | Always the same |

**What happens:**
```
1. Verify signature âœ“
2. Check sender.balance â‰¥ value + gas_fees âœ“
3. sender.balance -= value
4. recipient.balance += value
5. sender.nonce += 1
```

---

#### 2ï¸âƒ£ Contract Deployment

> **Banking analogy:** Opening a new automated escrow account with specific rules. You're not sending money to someone â€” you're creating a new rule-based account.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | `None` | **No recipient** â€” signals deployment |
| `value` | Usually 0 | Initial balance for contract (optional) |
| `data` | Bytecode | The contract's compiled code |
| `gas_limit` | Variable | Depends on bytecode size + initialization |

**What happens:**
```
1. Verify signature âœ“
2. Compute contract address = hash(sender, nonce)
3. Create new account at that address
4. Store bytecode in contract account
5. Execute constructor (initialization code)
6. sender.nonce += 1
```

**Key insight:** The contract address is deterministic â€” you can know it *before* deploying!

---

#### 3ï¸âƒ£ Contract Call

> **Banking analogy:** Triggering a standing instruction on a corporate account. You send a request (and optionally money), and the account's pre-programmed rules execute.

| Field | Value | Meaning |
|-------|-------|---------|
| `to` | Contract address | Which contract to interact with |
| `value` | Optional | Send money along with the call |
| `data` | Calldata | Function selector + encoded arguments |
| `gas_limit` | Variable | Depends on what the code does |

**What happens:**
```
1. Verify signature âœ“
2. Load contract code from `to` address
3. Execute code with `data` as input
4. Code may: read/write storage, send funds, call other contracts
5. If success: state changes persist
6. If failure: all changes reverted (but gas still consumed!)
```

---

#### Quick Comparison

| | Transfer | Deploy | Call |
|--|----------|--------|------|
| **`to`** | Recipient | `None` | Contract |
| **`data`** | Empty | Bytecode | Calldata |
| **`value`** | Amount | Initial balance | Payment to contract |
| **Gas** | Fixed (21k) | Variable | Variable |
| **Creates account?** | No* | Yes | No |
| **Executes code?** | No | Constructor only | Yes |

*\*Transfer creates recipient account if it doesn't exist (with zero code)*

<Aside type="note">
**How does the blockchain know which type?**
- `to == None` â†’ Deployment
- `to == EOA` (no code) â†’ Transfer
- `to == Contract` (has code) â†’ Call

The `data` field confirms intent: empty for transfers, bytecode for deploy, calldata for calls.
</Aside>

### Signing Transactions

We sign the hash of the transaction data (excluding the signature itself):

```rust
impl Transaction {
    pub fn signing_hash(&self) -> Hash {
        // Serialize everything except signature
        let unsigned = UnsignedTransaction { /* ... */ };
        let encoded = bincode::serialize(&unsigned).unwrap();
        hash(&encoded)
    }

    pub fn sign(&mut self, keypair: &Keypair) {
        let hash = self.signing_hash();
        self.signature = keypair.sign_hash(&hash);
    }
}
```

### Contract Address Derivation

When deploying a contract, the address is deterministic:

```rust
pub fn contract_address(&self) -> Option<Address> {
    if !self.is_deploy() {
        return None;
    }
    // Address = hash(sender || nonce)[0..20]
    let mut data = Vec::new();
    data.extend_from_slice(&self.from.0);
    data.extend_from_slice(&self.nonce.to_le_bytes());
    let h = hash(&data);
    // First 20 bytes
    Some(Address(h.0[..20].try_into().unwrap()))
}
```

<Aside type="caution">
This means you can predict contract addresses before deployment! This enables patterns like counterfactual instantiation.
</Aside>

<Aside type="tip" title="Trivia: What's NOT in the Address?">
Notice the formula: `address = hash(sender + nonce)` â€” the **bytecode is not included**.

*"Does this mean identical contracts get the same address?"* â€” No!

| Scenario | Result |
|----------|--------|
| Same person deploys same contract twice | **Different addresses** (nonce increments) |
| Two people deploy identical contracts | **Different addresses** (different senders) |

You can deploy unlimited copies of the same logic â€” each gets a unique address. This is intentional:
- **Multiple instances** â€” Deploy 10 token contracts with same code, different state
- **No race conditions** â€” Two people deploying identical code don't collide

**Ethereum's CREATE2** is an alternative that *does* include bytecode:
```
address = hash(0xff + sender + salt + hash(bytecode))
```
This gives deterministic addresses for the same code (useful for cross-chain deployments). Our implementation uses the simpler CREATE formula.
</Aside>

---

## 1.5 Blocks

A block packages transactions into an ordered, tamper-evident unit.

### Block Header

```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockHeader {
    pub height: u64,
    pub timestamp: u64,
    pub prev_hash: Hash,
    pub merkle_root: Hash,
    pub state_root: Hash,
    pub author: Address,
    pub difficulty: u64,
    pub nonce: u64,
}
```



### Need of `height` and `timestamp`

Straightforward â€” block number (0-indexed from genesis) and Unix timestamp when the block was produced.

---

### `prev_hash` â€” The Chain Link

Hash of the previous block's header. This is what makes it a *chain* â€” each block cryptographically commits to its parent. Tamper with any historical block â†’ all subsequent hashes change â†’ immediately detectable.

---

### `merkle_root` â€” Transaction Commitment

A block can contain hundreds of transactions, but we represent them with a single 32-byte hash:

```
Tx0   Tx1   Tx2   Tx3        â† 4 transactions
 â†“     â†“     â†“     â†“
H0    H1    H2    H3         â† hash each one
  \  /        \  /
   H01         H23           â† hash pairs together
      \       /
       merkle_root           â† single hash commits to ALL transactions
```

Change any transaction â†’ the root changes. This is a **merkle tree** â€” we'll cover it in detail in [section 1.6](#16-merkle-trees).

---

### `state_root` â€” World State Commitment and the need of it.

While `merkle_root` commits to the **inputs** (transactions), `state_root` commits to the **outputs** (resulting world state after execution).

```
Before Block 5:                     After Block 5:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Alice: 100 coins â”‚               â”‚ Alice: 70 coins  â”‚  â† sent 30
â”‚ Bob:   50 coins  â”‚  â”€â”€[txs]â”€â”€â”€â–º  â”‚ Bob:   80 coins  â”‚  â† received 30
â”‚ Contract X: ...  â”‚               â”‚ Contract X: ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“                                  â†“
   state_root_4                       state_root_5
```



| Use Case | How state_root Helps |
|----------|---------------------|
| **Consensus** | Nodes must agree on the *result*, not just the transactions. Same txs must produce same state_root, or something's wrong. |
| **Light clients** | Ask "What's Alice's balance?" â†’ get merkle proof against state_root. No need to download all accounts. |
| **State sync** | New node downloads current state, verifies against latest state_root. No need to replay all history from genesis. |
| **Detecting bugs** | If two nodes get different state_roots from same transactions â†’ non-determinism bug (serious!). |

**The key insight:** `merkle_root` proves "these transactions were included." `state_root` proves "executing them produced this exact world state."

**Is it built the same way as merkle_root?**

Both are merkle roots, but the underlying structure differs:

| | `merkle_root` | `state_root` |
|--|---------------|--------------|
| **Data** | List of transactions | Map of address â†’ account |
| **Structure** | Simple merkle tree | Merkle Patricia Trie |
| **Access** | Sequential (all txs) | Key-value lookup (by address) |
| **Updates** | Build fresh each block | Incremental (only changed accounts) |

Transactions are a **list** â€” simple merkle tree works. Accounts are a **key-value map** with millions of entries â€” needs a **trie** (prefix tree) for efficient lookups and partial updates.

**Why this matters: No need to replay history!**

Without `state_root`, answering "What's Alice's balance?" would require:
```
Start at genesis â†’ replay Block 1 â†’ replay Block 2 â†’ ... â†’ replay Block 1,000,000
"Alice has 70 coins"
```

With `state_root`, you just:
```
Look up Alice in current state trie â†’ verify proof against state_root
"Alice has 70 coins" âœ“
```

The entire history is "compressed" into the latest state. You don't trace back â€” you look up directly.

We'll explore the state trie implementation in [Chapter 2: Storage](/part2/chapter2-storage).

---

### `author` â€” Block Producer

In a single-authority PoA, you might wonder: "We know who the authority is, why store `author`?"

**Single authority:** Technically redundant â€” every block is signed by the same authority.

**Multiple rotating authorities:**
```
Authorities = [Alice, Bob, Carol]
Block 0 â†’ Alice's turn
Block 1 â†’ Bob's turn
Block 2 â†’ Carol's turn
```

Even here, you *could* derive author from `height % num_authorities`. But explicit `author` helps when:

| Scenario | Why author is useful |
|----------|---------------------|
| **Authority skips slot** | If Bob is offline, Alice produces block 1 instead. Can't derive from height. |
| **Dynamic authority set** | Authorities added/removed over time. History needs to record who actually signed. |
| **Self-describing blocks** | Block makes sense without external context (which authority set was active at that height?). |

**Also: Ed25519 requires it.** Unlike secp256k1 (Ethereum), you can't recover the public key from an Ed25519 signature. So we need `author` to look up the correct public key for verification.

We'll decide between single vs rotating authorities when implementing the consensus layer in [Chapter 5](/part5/chapter5-chain).

---

### `difficulty` and `nonce` â€” PoW Artifacts

These fields are **Proof of Work** concepts that don't really apply to PoA:

**In PoW (Bitcoin, old Ethereum):**
```
difficulty = how hard the mining puzzle is
nonce = the value miners iterate to solve: hash(block + nonce) < target
```

Miners burn electricity trying billions of nonces until they find a valid hash. Higher difficulty = more attempts needed.

**In PoA:** No puzzle. The authority just signs. Both fields are meaningless.

**So why include them?**

Some PoA chains repurpose `difficulty`:

| Chain | Repurposed meaning |
|-------|-------------------|
| **Clique (Geth)** | `2` = in-turn validator, `1` = out-of-turn (helps fork choice) |
| **Aura (Parity)** | Step number in rotation |

**For minichain:** We keep them as placeholders for now. A truly minimal PoA chain could remove both â€” we may do so once we finalize the consensus design in [Chapter 5](/part5/chapter5-chain).

---

### Block Size: How Many Transactions Fit?

A block can't grow forever â€” we need limits. Different blockchains use different approaches:

| Approach | How It Works | Used By |
|----------|--------------|---------|
| **Byte size** | Raw data limit (e.g., 1MB) | Bitcoin |
| **Gas limit** | Total computation budget per block | Ethereum |
| **Transaction count** | Direct cap on number of txs | Some chains |

**Why gas limit is the best fit for smart contract chains:**

| Limit Type | Problem |
|------------|---------|
| Max transactions | 1000 complex contract calls could take minutes to execute |
| Max bytes | Small bytecode can still have expensive infinite loops |
| **Max gas** | Directly limits computation time, regardless of tx count or size |

With a block gas limit, the math becomes predictable:

```
BLOCK_GAS_LIMIT = 30,000,000

Block can fit:
â”œâ”€ ~1,428 simple transfers (21,000 gas each)
â”œâ”€ OR ~60 complex contract calls (500,000 gas each)
â””â”€ OR any mix where total_gas â‰¤ 30M
```

**The block producer's algorithm:**

```rust
while let Some(tx) = mempool.next_by_gas_price() {
    if block.total_gas() + tx.gas_limit <= BLOCK_GAS_LIMIT {
        block.add(tx);
    }
}
```

Higher `gas_price` = picked first. This is why fees spike when the network is busy â€” users outbid each other for limited block space.

<Aside type="note" title="What's a Mempool?">
When you submit a transaction, it doesn't go directly into a block. It enters the **mempool** (memory pool) â€” a waiting room for pending transactions.

```
User submits tx â†’ [Mempool] â†’ Block producer picks txs â†’ [Block]
                     â†‘
            Other pending txs waiting here
```

**Message Queue Analogy:**

If you've used RabbitMQ, Kafka, or AWS SQS, the mempool works similarly:

| Message Queue | Blockchain Mempool |
|---------------|-------------------|
| Producer submits job | User submits transaction |
| Queue holds pending jobs | Mempool holds pending txs |
| Worker picks jobs (FIFO or priority) | Block producer picks txs (by `gas_price`) |
| Job gets processed | Transaction gets included in block |
| Acknowledgment | Transaction confirmed on-chain |

The key difference: in a message queue, workers typically process jobs FIFO (first-in-first-out). In a mempool, it's a **priority queue** â€” whoever pays the highest `gas_price` jumps the line.

**What if the mempool is nearly empty?**

Unlike message queues that might wait for a batch to fill, blockchains are **time-driven, not fullness-driven**:

```
Block interval = 12 seconds

â”œâ”€ Mempool has 1000 txs? â†’ Produce block with top txs up to gas limit
â”œâ”€ Mempool has 5 txs?    â†’ Produce block with those 5 txs
â””â”€ Mempool is empty?     â†’ Produce empty block (still valid!)
```

*Think of it like a scheduled bus:* the bus leaves at 9:00 AM whether it's packed or has one passenger. Waiting for a "full" bus would make arrival times unpredictable.

**Why not wait for a full block?**
- **Liveness** â€” users expect predictable confirmation times
- **Consensus** â€” fixed intervals simplify block timing and validation
- **Empty blocks are cheap** â€” a block with no transactions still advances the chain, updates timestamps, and maintains heartbeat

**Why do we need it?**
- **Blocks aren't instant** â€” transactions arrive continuously, but blocks are produced periodically (e.g., every 12 seconds)
- **Prioritization** â€” producers pick highest `gas_price` first, so the mempool must be sortable
- **Validation staging** â€” basic checks (valid signature, sufficient balance) happen before entering the mempool
- **Network propagation** â€” nodes share their mempools so transactions reach block producers

**Without a mempool:** You'd need to produce a block for every single transaction â€” no batching, no prioritization, extremely inefficient.

We'll implement the mempool in [Chapter 5](/part5/chapter5-chain) as part of the chain orchestration layer.
</Aside>

<Aside type="tip">
In minichain, the block gas limit would be enforced in the consensus layer when validating blocks. The `Block::total_gas_limit()` method sums all transaction gas limits for this check.
</Aside>

### The Chain of Blocks

Each block references its parent via `prev_hash`:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Block 0 â”‚â—„â”€â”€â”€â”‚ Block 1 â”‚â—„â”€â”€â”€â”‚ Block 2 â”‚
â”‚ Genesis â”‚    â”‚         â”‚    â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
prev_hash=0    prev_hash=     prev_hash=
               hash(Block0)   hash(Block1)
```

### Genesis Block

The genesis block is special â€” it has no parent:

```rust
impl Block {
    pub fn genesis(authority: Address) -> Self {
        Self {
            header: BlockHeader {
                height: 0,
                timestamp: BlockHeader::current_timestamp(),
                prev_hash: Hash::ZERO,  // No parent!
                merkle_root: Hash::ZERO,
                state_root: Hash::ZERO,
                author: authority,
                difficulty: 1,
                nonce: 0,
            },
            transactions: Vec::new(),
            signature: Signature::default(),
        }
    }
}
```

### Block Signing (PoA)

In Proof of Authority, the designated authority signs each block:

```rust
impl Block {
    pub fn sign(&mut self, keypair: &Keypair) {
        let hash = self.header.hash();
        self.signature = keypair.sign_hash(&hash);
    }

    pub fn verify_signature(&self, public_key: &PublicKey) -> bool {
        let hash = self.header.hash();
        public_key.verify(hash.as_bytes(), &self.signature).is_ok()
    }
}
```

---

## 1.6 Merkle Trees

A merkle tree lets us summarize many items into a single hash, with efficient proofs.

### Structure

```
        Root
       /    \
      H01    H23
     /  \   /  \
    H0  H1 H2  H3   â† Transaction hashes
```

### Computing the Root

```rust
pub fn merkle_root(hashes: &[Hash]) -> Hash {
    if hashes.is_empty() {
        return Hash::ZERO;
    }
    if hashes.len() == 1 {
        return hashes[0];
    }

    let mut current_level: Vec<Hash> = hashes.to_vec();

    while current_level.len() > 1 {
        let mut next_level = Vec::new();
        for chunk in current_level.chunks(2) {
            let combined = if chunk.len() == 2 {
                hash_concat(&[chunk[0].as_ref(), chunk[1].as_ref()])
            } else {
                // Odd number: hash with itself
                hash_concat(&[chunk[0].as_ref(), chunk[0].as_ref()])
            };
            next_level.push(combined);
        }
        current_level = next_level;
    }

    current_level[0]
}
```

### Why Merkle Trees?

1. **Integrity** â€” Any change to any transaction changes the root
2. **Efficiency** â€” Prove inclusion in O(log n) space
3. **Light clients** â€” Verify transactions without full block data

### Merkle Proofs

```rust
pub struct MerkleProof {
    pub leaf: Hash,           // The item being proven
    pub siblings: Vec<Hash>,  // Sibling hashes on path to root
    pub directions: Vec<bool>, // Left or right at each level
}
```

To verify: reconstruct the path from leaf to root using siblings.

---

## Summary

We've built the cryptographic foundation:

| Component | What It Does |
|-----------|--------------|
| `Hash` | 256-bit Blake3 digest |
| `Address` | 160-bit identity derived from public key |
| `Keypair` | Ed25519 key pair for signing |
| `Account` | User or contract state |
| `Transaction` | Signed state change request |
| `Block` | Ordered batch of transactions |
| `MerkleTree` | Efficient transaction commitment |

### Tests Passing

```bash
$ cargo test -p minichain-core

running 47 tests
test account::tests::test_new_user_account ... ok
test crypto::tests::test_sign_and_verify ... ok
test block::tests::test_genesis_block ... ok
test merkle::tests::test_merkle_proof_valid ... ok
# ... all 47 tests pass
```

---

## What's Next?

With our primitives in place, we're ready to build the **storage layer** in [Chapter 2](/part2/chapter2-storage), where we'll persist accounts, blocks, and contract state using sled.
